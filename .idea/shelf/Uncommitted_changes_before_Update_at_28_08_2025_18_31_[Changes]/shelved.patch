Index: engine/src/logic/program/Program.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.program;\r\n\r\nimport logic.instructions.Instruction;\r\nimport logic.labels.Label;\r\nimport logic.variables.Variable;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic interface Program {\r\n    public void run(int degree);\r\n    void addInstruction(Instruction instruction);\r\n\r\n    String getName();\r\n    List<Instruction> getInstructions();\r\n    Map<Label, Instruction> getLabels();\r\n\r\n    int maxDegree();\r\n    int cycles();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/program/Program.java b/engine/src/logic/program/Program.java
--- a/engine/src/logic/program/Program.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/program/Program.java	(date 1756393622884)
@@ -16,4 +16,6 @@
 
     int maxDegree();
     int cycles();
+
+    boolean checkLabels();
 }
Index: engine/src/logic/program/SProgram.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.program;\r\n\r\nimport logic.instructions.Instruction;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\n\r\nimport java.util.*;\r\n\r\npublic class SProgram implements Program {\r\n    private String name;\r\n    private List<Instruction> instructions;\r\n    private Map<Label, Instruction> labels;\r\n\r\n    public SProgram(String name, Map<Label, Instruction> labels) {\r\n        this.name = name;\r\n        this.instructions = new ArrayList<>();\r\n        this.labels = labels; // labels must map each label to its instruction\r\n    }\r\n\r\n    public SProgram(String name, Map<Label, Instruction> labels, List<Instruction> instructions) {\r\n        this.name = name;\r\n        this.instructions = instructions;\r\n        this.labels = labels; // labels must map each label to its instruction\r\n    }\r\n\r\n\r\n    @Override\r\n    public void run(int degree) {\r\n        Label nextLabel;\r\n        int pc = 0;\r\n\r\n        while (0 <= pc && pc < instructions.size()) {\r\n            Instruction current = instructions.get(pc);\r\n            nextLabel = current.execute();\r\n            //System.out.println(\"pc = \" + pc); // for debugging\r\n            if (FixedLabel.EXIT == nextLabel) {\r\n                break;\r\n            }\r\n\r\n            if (FixedLabel.EMPTY != nextLabel) {\r\n                Instruction target = labels.get(nextLabel);\r\n                if (target == null) {\r\n                    throw new IllegalStateException(\"Unknown label: \" + nextLabel.getLabel());\r\n                }\r\n                int idx = instructions.indexOf(target);\r\n                if (idx < 0) {\r\n                    throw new IllegalStateException(\"Label not in instruction list: \" + nextLabel.getLabel());\r\n                }\r\n                pc = idx;\r\n            } else {\r\n                pc += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void addInstruction(Instruction instruction) {\r\n        // the variables in instruction must be the same instances saved in\r\n        // tempVars and inputVars - the provided lists of variables in the program\r\n        Label selfLabel = instruction.getSelfLabel();\r\n        if (selfLabel != FixedLabel.EMPTY) {\r\n            labels.put(selfLabel, instruction);\r\n        }\r\n        instructions.add(instruction);\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public List<Instruction> getInstructions() {\r\n        return instructions;\r\n    }\r\n\r\n    @Override\r\n    public Map<Label, Instruction> getLabels() {\r\n        return labels;\r\n    }\r\n\r\n    @Override\r\n    public int maxDegree() {\r\n        return instructions.stream()\r\n                .mapToInt(Instruction::getDegree)\r\n                .max().orElse(0);\r\n    }\r\n\r\n    @Override\r\n    public int cycles() {\r\n        return instructions.stream()\r\n                .mapToInt(Instruction::getCycles)\r\n                .sum();\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/program/SProgram.java b/engine/src/logic/program/SProgram.java
--- a/engine/src/logic/program/SProgram.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/program/SProgram.java	(date 1756394425336)
@@ -93,4 +93,22 @@
                 .sum();
     }
 
+    @Override
+    public boolean checkLabels() {
+        List<Label> usedLabels = new ArrayList<>();
+        for (Instruction instruction : instructions) {
+            Label usedLabel = instruction.getTargetLabel();
+            if (usedLabel != FixedLabel.EMPTY) {
+                usedLabels.add(usedLabel);
+            }
+        }
+
+        for  (Label label : usedLabels) {
+            if (!labels.containsKey(label)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
 }
Index: engine/src/logic/instructions/Instruction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions;\r\nimport logic.labels.Label;\r\n\r\npublic interface Instruction {\r\n    String getRepresentation(int num);\r\n\r\n    String print();\r\n\r\n    Label execute();\r\n\r\n    int getCycles();\r\n\r\n    Label getSelfLabel();\r\n\r\n    int getDegree();\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/Instruction.java b/engine/src/logic/instructions/Instruction.java
--- a/engine/src/logic/instructions/Instruction.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/Instruction.java	(date 1756393721854)
@@ -13,4 +13,6 @@
     Label getSelfLabel();
 
     int getDegree();
+
+    Label getTargetLabel();
 }
\ No newline at end of file
Index: engine/src/logic/instructions/api/AbstractInstruction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions.api;\r\nimport logic.instructions.Instruction;\r\nimport logic.instructions.InstructionData;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\n\r\npublic abstract class AbstractInstruction implements Instruction {\r\n    private final Label selfLabel;\r\n    private final InstructionData data;\r\n\r\n    public AbstractInstruction(InstructionData data) {\r\n        this(data, FixedLabel.EMPTY);\r\n    }\r\n\r\n    public AbstractInstruction(InstructionData data, Label selfLabel) {\r\n        this.data = data;\r\n        this.selfLabel = selfLabel;\r\n    }\r\n\r\n    @Override\r\n    public Label getSelfLabel() { return selfLabel; }\r\n\r\n    @Override\r\n    public String getRepresentation(int num) {\r\n        return String.format(\"#%d (%s) [ %-3s ] %s (%d)\",\r\n                num,\r\n                data.getInstructionType(),\r\n                selfLabel.getLabel(),\r\n                this.print(),\r\n                data.getCycles());\r\n    }\r\n\r\n    @Override\r\n    public int getCycles() { return data.getCycles(); }\r\n\r\n    @Override\r\n    public int getDegree() { return data.getDegree(); }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/api/AbstractInstruction.java b/engine/src/logic/instructions/api/AbstractInstruction.java
--- a/engine/src/logic/instructions/api/AbstractInstruction.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/api/AbstractInstruction.java	(date 1756393735872)
@@ -35,4 +35,7 @@
 
     @Override
     public int getDegree() { return data.getDegree(); }
+
+    @Override
+    public Label getTargetLabel() { return FixedLabel.EMPTY; }
 }
Index: engine/src/logic/instructions/api/basic/JumpNotZero.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions.api.basic;\r\nimport logic.instructions.InstructionData;\r\nimport logic.instructions.api.AbstractInstruction;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\nimport logic.variables.Variable;\r\n\r\npublic class JumpNotZero extends AbstractInstruction {\r\n\r\n    private final Variable v;\r\n    private final Label target;\r\n\r\n    public JumpNotZero(Label selfLabel, Variable v, Label target) {\r\n        super(InstructionData.JUMP_NOT_ZERO, selfLabel);\r\n        this.v = v;\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public Label execute() {\r\n        if (v.getValue() != 0) return target;\r\n        else return FixedLabel.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public String print() {\r\n        return \"IF \" + v.getName() + \" != 0 GOTO \" + target.getLabel();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/api/basic/JumpNotZero.java b/engine/src/logic/instructions/api/basic/JumpNotZero.java
--- a/engine/src/logic/instructions/api/basic/JumpNotZero.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/api/basic/JumpNotZero.java	(date 1756393760533)
@@ -26,4 +26,9 @@
     public String print() {
         return "IF " + v.getName() + " != 0 GOTO " + target.getLabel();
     }
+
+    @Override
+    public Label getTargetLabel() {
+        return target;
+    }
 }
Index: engine/src/logic/instructions/api/synthetic/JumpEqualConstant.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions.api.synthetic;\r\n\r\nimport logic.instructions.InstructionData;\r\nimport logic.instructions.api.AbstractInstruction;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\nimport logic.variables.Var;\r\nimport logic.variables.Variable;\r\n\r\npublic class JumpEqualConstant extends AbstractInstruction {\r\n\r\n    private final Variable v;\r\n    private final Label target;\r\n    private final int k;\r\n\r\n    public JumpEqualConstant(Label selfLabel, Variable v, int k, Label target) {\r\n        super(InstructionData.JUMP_EQUAL_CONSTANT, selfLabel);\r\n        this.v = v;\r\n        this.target = target;\r\n        this.k = k;\r\n    }\r\n\r\n    @Override\r\n    public Label execute() {\r\n        if (v.getValue() == k) return target;\r\n        else return FixedLabel.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public String print() {\r\n        return \"IF \" + v.getName() + \" = \" + k + \" GOTO \" + target.getLabel();\r\n    }\r\n    public Variable getVariable() { return v; }\r\n    public int getConstant() { return k; }\r\n    public Label getTargetLabel() { return target; }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/api/synthetic/JumpEqualConstant.java b/engine/src/logic/instructions/api/synthetic/JumpEqualConstant.java
--- a/engine/src/logic/instructions/api/synthetic/JumpEqualConstant.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/api/synthetic/JumpEqualConstant.java	(date 1756393786560)
@@ -32,5 +32,9 @@
     }
     public Variable getVariable() { return v; }
     public int getConstant() { return k; }
-    public Label getTargetLabel() { return target; }
+
+    @Override
+    public Label getTargetLabel() {
+        return target;
+    }
 }
Index: engine/src/logic/instructions/api/synthetic/JumpEqualVariable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions.api.synthetic;\r\n\r\nimport logic.instructions.InstructionData;\r\nimport logic.instructions.api.AbstractInstruction;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\nimport logic.variables.Var;\r\nimport logic.variables.Variable;\r\n\r\npublic class JumpEqualVariable extends AbstractInstruction {\r\n\r\n    private final Variable x;\r\n    private final Label target;\r\n    private final Variable y;\r\n\r\n    public JumpEqualVariable(Label selfLabel, Variable x, Variable y, Label target) {\r\n        super(InstructionData.JUMP_EQUAL_VARIABLE, selfLabel);\r\n        this.x = x;\r\n        this.y = y;\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public Label execute() {\r\n        if (x.getValue() == y.getValue()) return target;\r\n        else return FixedLabel.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public String print() {\r\n        return \"IF \" + x.getName() + \" = \" + y.getName() + \" GOTO \" + target.getLabel();\r\n    }\r\n    public Variable getVar1() { return x; }\r\n    public Variable getVar2() { return y; }\r\n    public Label getTargetLabel() { return target; }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/api/synthetic/JumpEqualVariable.java b/engine/src/logic/instructions/api/synthetic/JumpEqualVariable.java
--- a/engine/src/logic/instructions/api/synthetic/JumpEqualVariable.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/api/synthetic/JumpEqualVariable.java	(date 1756393798278)
@@ -32,5 +32,9 @@
     }
     public Variable getVar1() { return x; }
     public Variable getVar2() { return y; }
-    public Label getTargetLabel() { return target; }
+
+    @Override
+    public Label getTargetLabel() {
+        return target;
+    }
 }
Index: engine/src/logic/instructions/api/synthetic/GoToLabel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions.api.synthetic;\r\n\r\nimport logic.instructions.InstructionData;\r\nimport logic.instructions.api.AbstractInstruction;\r\nimport logic.labels.Label;\r\n\r\n\r\npublic class GoToLabel extends AbstractInstruction {\r\n\r\n    private final Label target;\r\n\r\n    public GoToLabel(Label selfLabel, Label target) {\r\n        super(InstructionData.GOTO_LABEL,  selfLabel);\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public Label execute() {\r\n        return target;\r\n    }\r\n\r\n    @Override\r\n    public String print() {\r\n        return \"GOTO \" + target.getLabel();\r\n    }\r\n    public Label getTargetLabel() { return target; }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/api/synthetic/GoToLabel.java b/engine/src/logic/instructions/api/synthetic/GoToLabel.java
--- a/engine/src/logic/instructions/api/synthetic/GoToLabel.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/api/synthetic/GoToLabel.java	(date 1756393774334)
@@ -23,5 +23,9 @@
     public String print() {
         return "GOTO " + target.getLabel();
     }
-    public Label getTargetLabel() { return target; }
+
+    @Override
+    public Label getTargetLabel() {
+        return target;
+    }
 }
\ No newline at end of file
Index: engine/src/execute/Engine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package execute;\r\n\r\nimport logic.variables.Variable;\r\n\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic interface Engine {\r\n    boolean loadFromXML(String filePath);\r\n\r\n    void printProgram();\r\n\r\n    long runProgram(int degree);\r\n\r\n    int maxDegree();\r\n\r\n    List<Variable> getInputs();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/execute/Engine.java b/engine/src/execute/Engine.java
--- a/engine/src/execute/Engine.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/execute/Engine.java	(date 1756394040899)
@@ -12,6 +12,8 @@
 
     long runProgram(int degree);
 
+    boolean validateProgram();
+
     int maxDegree();
 
     List<Variable> getInputs();
Index: engine/src/execute/EngineImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package execute;\r\n\r\nimport logic.instructions.Instruction;\r\nimport logic.instructions.InstructionData;\r\nimport logic.instructions.api.basic.Decrease;\r\nimport logic.instructions.api.basic.Increase;\r\nimport logic.instructions.api.basic.JumpNotZero;\r\nimport logic.instructions.api.basic.Neutral;\r\nimport logic.instructions.api.synthetic.*;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\nimport logic.labels.NumericLabel;\r\nimport logic.program.Program;\r\nimport logic.variables.Var;\r\nimport logic.variables.Variable;\r\nimport logic.variables.VariableType;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class EngineImpl implements Engine {\r\n    Program currentProgram;\r\n    Map<String, Variable> currentVars;\r\n\r\n    public EngineImpl() {}\r\n\r\n    @Override\r\n    public boolean loadFromXML(String filePath) {\r\n        Map<String, Variable> vars = new HashMap<>();\r\n        Program program = XmlLoader.parse(filePath, vars);\r\n        if (program != null) {\r\n            this.currentProgram = program;\r\n            this.currentVars = vars;\r\n            System.out.println(\"Program '\" + program.getName() + \"' loaded successfully!\");\r\n            return true;\r\n        } else {\r\n            System.out.println(\"Program not loaded. Keeping previous program.\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void printProgram() {\r\n        if (currentProgram == null) {\r\n            System.out.println(\"No program loaded.\");\r\n            return;\r\n        }\r\n        List<Instruction> instrList = currentProgram.getInstructions();\r\n        for (int i = 0; i < instrList.size(); i++) {\r\n            Instruction instr = instrList.get(i);\r\n            System.out.println(instr.getRepresentation(i + 1));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public long runProgram(int degree) {\r\n        currentProgram.run(degree);\r\n        long result = currentVars.get(\"y\").getValue();\r\n        currentVars.values().forEach(v -> v.setValue(0)); // reset vars\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public int maxDegree() {\r\n        return currentProgram.maxDegree();\r\n    }\r\n\r\n    @Override\r\n    public List<Variable> getInputs() {\r\n        return currentVars.values().stream()\r\n                .filter(Objects::nonNull)\r\n                .filter(v -> v.getType() == VariableType.INPUT)\r\n                .sorted(Comparator.comparing(Variable::getName))\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    // ========= expandProgram =========\r\n\r\n    public void expandProgram(int degree) {\r\n        if (currentProgram == null) {\r\n            System.out.println(\"No program loaded.\");\r\n            return;\r\n        }\r\n\r\n        List<ExpandedInstruction> expanded = expandRecursive(\r\n                currentProgram.getInstructions(), degree, new ArrayList<>()\r\n        );\r\n\r\n        for (int i = 0; i < expanded.size(); i++) {\r\n            System.out.println(expanded.get(i).getRepresentation(i + 1));\r\n        }\r\n    }\r\n\r\n    private List<ExpandedInstruction> expandRecursive(List<Instruction> instrs,\r\n                                                      int degree,\r\n                                                      List<Instruction> history) {\r\n        List<ExpandedInstruction> result = new ArrayList<>();\r\n\r\n        for (Instruction instr : instrs) {\r\n            if (instr.getDegree() > 0 && degree > 0) {\r\n                // expand synthetic instruction\r\n                List<Instruction> expansion = expandOne(instr); //todoo\r\n                for (Instruction child : expansion) {\r\n                    List<Instruction> newHistory = new ArrayList<>(history);\r\n                    newHistory.add(instr);\r\n                    result.addAll(expandRecursive(List.of(child), degree - 1, newHistory));\r\n                }\r\n            } else {\r\n                result.add(new ExpandedInstruction(instr, history));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private List<Instruction> expandOne(Instruction instr) {\r\n        List<Instruction> result = new ArrayList<>();\r\n        Label self = instr.getSelfLabel();\r\n\r\n        // ---- ZERO_VARIABLE ----\r\n        if (instr instanceof ZeroVariable zv) {\r\n            Variable v = zv.getVariable();\r\n            Label loop = freshLabel();\r\n            result.add(new JumpNotZero(self, v, loop));\r\n            result.add(new Decrease(loop, v));\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, v, loop));\r\n        }\r\n\r\n        // ---- CONSTANT_ASSIGNMENT ----\r\n        else if (instr instanceof ConstantAssignment ca) {\r\n            Variable v = ca.getVariable();\r\n            int k = ca.getConstant();\r\n            result.add(new ZeroVariable(self, v));\r\n            for (int i = 0; i < k; i++) {\r\n                result.add(new Increase(FixedLabel.EMPTY, v));\r\n            }\r\n        }\r\n\r\n        // ---- ASSIGNMENT ----\r\n        else if (instr instanceof Assignment asg) {\r\n            Variable x = asg.getX();\r\n            Variable y = asg.getY();\r\n            Label loop = freshLabel();\r\n            result.add(new ZeroVariable(self, x));\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, y, loop));\r\n            result.add(new Decrease(loop, y));\r\n            result.add(new Increase(FixedLabel.EMPTY, x));\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, y, loop));\r\n        }\r\n\r\n        // ---- GOTO_LABEL ----\r\n        else if (instr instanceof GoToLabel gtl) {\r\n            Label target = gtl.getTargetLabel();\r\n            Variable dummy = freshTemp();\r\n            result.add(new Increase(self, dummy));      // dummy = 1\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, dummy, target));\r\n        }\r\n\r\n        // ---- JUMP_ZERO ----\r\n        else if (instr instanceof JumpZero jz) {\r\n            Variable v = jz.getVariable();\r\n            Label target = jz.getTargetLabel();\r\n            Label skip = freshLabel();\r\n            result.add(new JumpNotZero(self, v, skip));\r\n            result.add(new GoToLabel(FixedLabel.EMPTY, target));\r\n            result.add(new Neutral(skip, v)); // skip:\r\n        }\r\n\r\n        // ---- JUMP_EQUAL_CONSTANT ----\r\n        else if (instr instanceof JumpEqualConstant jec) {\r\n            Variable v = jec.getVariable();\r\n            int k = jec.getConstant();\r\n            Label target = jec.getTargetLabel();\r\n\r\n            Variable tmp = freshTemp();\r\n            result.add(new Assignment(self, tmp, v));\r\n            result.add(new ConstantAssignment(FixedLabel.EMPTY, tmp, k));\r\n            // subtract tmp - k loop\r\n            Label loop = freshLabel();\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, tmp, loop));\r\n            result.add(new Decrease(loop, tmp));\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, tmp, loop));\r\n            result.add(new JumpZero(FixedLabel.EMPTY, tmp, target));\r\n        }\r\n\r\n        // ---- JUMP_EQUAL_VARIABLE ----\r\n        else if (instr instanceof JumpEqualVariable jev) {\r\n            Variable v1 = jev.getVar1();\r\n            Variable v2 = jev.getVar2();\r\n            Label target = jev.getTargetLabel();\r\n\r\n            Variable t1 = freshTemp();\r\n            Variable t2 = freshTemp();\r\n            result.add(new Assignment(self, t1, v1));\r\n            result.add(new Assignment(FixedLabel.EMPTY, t2, v2));\r\n\r\n            Label loop = freshLabel();\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, t2, loop));\r\n            result.add(new Decrease(loop, t1));\r\n            result.add(new Decrease(FixedLabel.EMPTY, t2));\r\n            result.add(new JumpNotZero(FixedLabel.EMPTY, t2, loop));\r\n            result.add(new JumpZero(FixedLabel.EMPTY, t1, target));\r\n        }\r\n\r\n        else {\r\n            result.add(instr);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    private static class ExpandedInstruction {\r\n        private final Instruction instruction;\r\n        private final List<Instruction> history;\r\n\r\n        ExpandedInstruction(Instruction instr, List<Instruction> parentHistory) {\r\n            this.instruction = instr;\r\n            this.history = new ArrayList<>(parentHistory);\r\n        }\r\n\r\n        String getRepresentation(int num) {\r\n            StringBuilder sb = new StringBuilder(instruction.getRepresentation(num));\r\n            for (Instruction h : history) {\r\n                sb.append(\"  <<<  \").append(h.getRepresentation(-1));\r\n            }\r\n            return sb.toString();\r\n        }\r\n    }\r\n    private static int labelCounter = 1;\r\n    private static int tempCounter = 1;\r\n\r\n    private static Label freshLabel() {\r\n        return new NumericLabel(labelCounter++);\r\n    }\r\n\r\n    private static Variable freshTemp() {\r\n        return new Var(\"z\" + (tempCounter++));\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/execute/EngineImpl.java b/engine/src/execute/EngineImpl.java
--- a/engine/src/execute/EngineImpl.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/execute/EngineImpl.java	(date 1756394062223)
@@ -60,6 +60,11 @@
         return result;
     }
 
+    @Override
+    public boolean validateProgram() {
+        return currentProgram.checkLabels();
+    }
+
     @Override
     public int maxDegree() {
         return currentProgram.maxDegree();
Index: engine/src/logic/instructions/api/synthetic/JumpZero.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.instructions.api.synthetic;\r\n\r\nimport logic.instructions.InstructionData;\r\nimport logic.instructions.api.AbstractInstruction;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\nimport logic.variables.Var;\r\nimport logic.variables.Variable;\r\n\r\npublic class JumpZero extends AbstractInstruction {\r\n\r\n    private final Variable v;\r\n    private final Label target;\r\n\r\n    public JumpZero(Label selfLabel, Variable v, Label target) {\r\n        super(InstructionData.JUMP_ZERO,  selfLabel);\r\n        this.v = v;\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public Label execute() {\r\n        if (v.getValue() == 0) return target;\r\n        else return FixedLabel.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public String print() {\r\n        return \"IF \" + v.getName() + \" = 0 GOTO \" + target.getLabel();\r\n    }\r\n    public Variable getVariable() { return v; }\r\n    public Label getTargetLabel() { return target; }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/logic/instructions/api/synthetic/JumpZero.java b/engine/src/logic/instructions/api/synthetic/JumpZero.java
--- a/engine/src/logic/instructions/api/synthetic/JumpZero.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/logic/instructions/api/synthetic/JumpZero.java	(date 1756393808429)
@@ -29,5 +29,9 @@
         return "IF " + v.getName() + " = 0 GOTO " + target.getLabel();
     }
     public Variable getVariable() { return v; }
-    public Label getTargetLabel() { return target; }
+
+    @Override
+    public Label getTargetLabel() {
+        return target;
+    }
 }
Index: engine/src/execute/XmlLoader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package execute;\r\n\r\nimport logic.instructions.*;\r\nimport logic.instructions.api.basic.*;\r\nimport logic.instructions.api.synthetic.*;\r\nimport logic.labels.FixedLabel;\r\nimport logic.labels.Label;\r\nimport logic.labels.NumericLabel;\r\nimport logic.program.Program;\r\nimport logic.program.SProgram;\r\nimport logic.variables.Var;\r\nimport logic.variables.Variable;\r\nimport org.w3c.dom.*;\r\n\r\nimport javax.xml.parsers.*;\r\nimport java.io.File;\r\nimport java.util.*;\r\n\r\npublic class XmlLoader {\r\n\r\n    public static Program parse(String filePath, Map<String, Variable> vars) {\r\n        File file = new File(filePath);\r\n        if (!file.exists()) {\r\n            System.out.println(\"Error: File does not exist.\");\r\n            return null;\r\n        }\r\n        if (!filePath.toLowerCase().endsWith(\".xml\")) {\r\n            System.out.println(\"Error: File is not an XML file.\");\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\r\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\r\n            Document doc = dBuilder.parse(file);\r\n            doc.getDocumentElement().normalize();\r\n\r\n            List<Instruction> instructions = new ArrayList<>();\r\n            Map<Label, Instruction> labels = new HashMap<>();\r\n\r\n            String programName = doc.getDocumentElement().getAttribute(\"name\");\r\n\r\n            NodeList instrNodes = doc.getElementsByTagName(\"S-Instruction\");\r\n            System.out.println(\"Found \" + instrNodes.getLength() + \" instructions in XML\");\r\n\r\n            for (int i = 0; i < instrNodes.getLength(); i++) {\r\n                Element instrElem = (Element) instrNodes.item(i);\r\n\r\n                String instrName = instrElem.getAttribute(\"name\");\r\n                String type = instrElem.getAttribute(\"type\");\r\n\r\n                // variable (main one if exists)\r\n                String varName = \"\";\r\n                Variable var = null;\r\n                NodeList varNodes = instrElem.getElementsByTagName(\"S-Variable\");\r\n                if (varNodes.getLength() > 0) {\r\n                    varName = varNodes.item(0).getTextContent().trim();\r\n                    if (!vars.containsKey(varName)) {\r\n                        vars.put(varName, new Var(varName));\r\n                    }\r\n                    var = vars.get(varName);\r\n                }\r\n\r\n                // label of the instruction\r\n                Label selfLabel = FixedLabel.EMPTY;\r\n                NodeList labelNodes = instrElem.getElementsByTagName(\"S-Label\");\r\n                if (labelNodes.getLength() > 0) {\r\n                    String labelName = labelNodes.item(0).getTextContent().trim();\r\n                    selfLabel = parseLabel(labelName);\r\n                }\r\n\r\n                // collect all arguments into a map\r\n                Map<String, String> args = new HashMap<>();\r\n                NodeList argParents = instrElem.getElementsByTagName(\"S-Instruction-Arguments\");\r\n                if (argParents.getLength() > 0) {\r\n                    Element argsElem = (Element) argParents.item(0);\r\n                    NodeList argNodes = argsElem.getElementsByTagName(\"S-Instruction-Argument\");\r\n                    for (int j = 0; j < argNodes.getLength(); j++) {\r\n                        Element argElem = (Element) argNodes.item(j);\r\n                        String argName = argElem.getAttribute(\"name\");\r\n                        String argValue = argElem.getAttribute(\"value\");\r\n                        args.put(argName, argValue);\r\n                    }\r\n                }\r\n\r\n                // some instructions have a target label directly\r\n                Label targetLabel = FixedLabel.EMPTY;\r\n                if (args.containsKey(\"JNZLabel\")) {\r\n                    targetLabel = parseLabel(args.get(\"JNZLabel\"));\r\n                }\r\n\r\n                Instruction instr = createInstruction(instrName, var, selfLabel, targetLabel, args, vars);\r\n                if (instr != null) {\r\n                    instructions.add(instr);\r\n                    if (selfLabel != FixedLabel.EMPTY) {\r\n                        labels.put(selfLabel, instr);\r\n                    }\r\n                } else {\r\n                    System.out.println(\"Unknown instruction name: \" + instrName + \" (type=\" + type + \")\");\r\n                }\r\n            }\r\n            return new SProgram(programName, labels, instructions);\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(\"Error parsing XML: \" + e.getMessage());\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private static Instruction createInstruction(String name,\r\n                                                 Variable var,\r\n                                                 Label selfLabel,\r\n                                                 Label target,\r\n                                                 Map<String, String> args,\r\n                                                 Map<String, Variable> vars) {\r\n        return switch (name.toUpperCase()) {\r\n            case \"INCREASE\" -> new Increase(selfLabel, var);\r\n            case \"DECREASE\" -> new Decrease(selfLabel, var);\r\n            case \"JUMP_NOT_ZERO\", \"JNZ\" -> new JumpNotZero(selfLabel, var, target);\r\n            case \"NEUTRAL\", \"NO_OP\" -> new Neutral(selfLabel, var);\r\n\r\n            // ---- Synthetic ----\r\n            case \"ZERO_VARIABLE\" -> new ZeroVariable(selfLabel, var);\r\n\r\n            case \"GOTO_LABEL\" -> {\r\n                String lbl = args.get(\"gotoLabel\");\r\n                Label tgt = parseLabel(lbl);\r\n                yield new GoToLabel(selfLabel, tgt);\r\n            }\r\n\r\n            case \"ASSIGNMENT\" -> {\r\n                // main variable from <S-Variable> is target (y)\r\n                String assignedVarName = args.get(\"assignedVariable\");\r\n                Variable targetVar = var; // <S-Variable> â†’ y\r\n                Variable sourceVar = vars.computeIfAbsent(assignedVarName, Var::new);\r\n                yield new Assignment(selfLabel, targetVar, sourceVar);\r\n            }\r\n\r\n            case \"CONSTANT_ASSIGNMENT\" -> {\r\n                int k = Integer.parseInt(args.get(\"constantValue\"));\r\n                yield new ConstantAssignment(selfLabel, var, k);\r\n            }\r\n\r\n            case \"JUMP_ZERO\" -> {\r\n                String lbl = args.get(\"JZLabel\");\r\n                Label tgt = parseLabel(lbl);\r\n                yield new JumpZero(selfLabel, var, tgt);\r\n            }\r\n\r\n            case \"JUMP_EQUAL_CONSTANT\" -> {\r\n                String lbl = args.get(\"JEConstantLabel\");\r\n                int k = Integer.parseInt(args.get(\"constantValue\"));\r\n                Label tgt = parseLabel(lbl);\r\n                yield new JumpEqualConstant(selfLabel, var, k, tgt);\r\n            }\r\n\r\n            case \"JUMP_EQUAL_VARIABLE\" -> {\r\n                String otherVarName = args.get(\"variableName\");\r\n                Variable otherVar = vars.computeIfAbsent(otherVarName, Var::new);\r\n                String lbl = args.get(\"JEVariableLabel\");\r\n                Label tgt = parseLabel(lbl);\r\n                yield new JumpEqualVariable(selfLabel, var, otherVar, tgt);\r\n            }\r\n\r\n            default -> null;\r\n        };\r\n    }\r\n\r\n\r\n    private static Label parseLabel(String labelValue) {\r\n        if (labelValue == null || labelValue.isEmpty()) return FixedLabel.EMPTY;\r\n\r\n        String v = labelValue.trim();\r\n        Label target;\r\n        char c0 = Character.toUpperCase(v.charAt(0));\r\n        switch (c0) {\r\n            case 'L' -> {\r\n                int n = Integer.parseInt(v.substring(1));\r\n                target = new NumericLabel(n);\r\n            }\r\n            case 'E' -> target = FixedLabel.EXIT;\r\n            default -> target = FixedLabel.EMPTY;\r\n        }\r\n        return target;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/src/execute/XmlLoader.java b/engine/src/execute/XmlLoader.java
--- a/engine/src/execute/XmlLoader.java	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/engine/src/execute/XmlLoader.java	(date 1756394587112)
@@ -99,7 +99,13 @@
                     System.out.println("Unknown instruction name: " + instrName + " (type=" + type + ")");
                 }
             }
-            return new SProgram(programName, labels, instructions);
+            Program program = new SProgram(programName, labels, instructions);
+
+            if (!program.checkLabels()) {
+                System.out.println("Error: Program has invalid labels.");
+                return null;
+            }
+            else return program;
 
         } catch (Exception e) {
             System.out.println("Error parsing XML: " + e.getMessage());
Index: .idea/artifacts/engine_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/artifacts/engine_jar.xml b/.idea/artifacts/engine_jar.xml
new file mode 100644
--- /dev/null	(date 1756393152972)
+++ b/.idea/artifacts/engine_jar.xml	(date 1756393152972)
@@ -0,0 +1,8 @@
+<component name="ArtifactManager">
+  <artifact type="jar" name="engine:jar">
+    <output-path>$PROJECT_DIR$/out/artifacts</output-path>
+    <root id="archive" name="engine.jar">
+      <element id="module-output" name="engine" />
+    </root>
+  </artifact>
+</component>
\ No newline at end of file
Index: engine/META-INF/MANIFEST.MF
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/META-INF/MANIFEST.MF b/engine/META-INF/MANIFEST.MF
new file mode 100644
--- /dev/null	(date 1756393152994)
+++ b/engine/META-INF/MANIFEST.MF	(date 1756393152994)
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+
Index: .idea/artifacts/ui_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/artifacts/ui_jar.xml b/.idea/artifacts/ui_jar.xml
new file mode 100644
--- /dev/null	(date 1756393152999)
+++ b/.idea/artifacts/ui_jar.xml	(date 1756393152999)
@@ -0,0 +1,8 @@
+<component name="ArtifactManager">
+  <artifact type="jar" name="ui:jar">
+    <output-path>$PROJECT_DIR$/out/artifacts</output-path>
+    <root id="archive" name="ui.jar">
+      <element id="module-output" name="ui" />
+    </root>
+  </artifact>
+</component>
\ No newline at end of file
Index: ui/src/META-INF/MANIFEST.MF
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ui/src/META-INF/MANIFEST.MF b/ui/src/META-INF/MANIFEST.MF
new file mode 100644
--- /dev/null	(date 1756393152988)
+++ b/ui/src/META-INF/MANIFEST.MF	(date 1756393152988)
@@ -0,0 +1,4 @@
+Manifest-Version: 1.0
+Main-Class: console.ConsoleUI
+Class-Path: engine.jar
+
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_24\" default=\"true\" project-jdk-name=\"openjdk-24\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision aab401c3bd5f666e76abe847a33787294059bc49)
+++ b/.idea/misc.xml	(date 1756393152983)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_24" default="true" project-jdk-name="openjdk-24" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="openjdk-24" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
